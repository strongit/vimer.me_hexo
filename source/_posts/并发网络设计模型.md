title: 并发网络设计模型
date: 2012-08-12 18:30:25
tags: [并发,C]
---
12年写的一篇博文, 现在博文迁移了部分到Github Page上.

这篇文主要讲述常用并发网络设计模型, 有异议或意见请底下留言.

####非阻塞模型:####

Socket函数默认都是阻塞式操作的, 比如Accept的阻塞的时候,是不能进行任何其它操作的, 除非开多个进程,主进程进行Accept, 子进程进行对连接Socket进行相应数据操作. 如果单进程的有没有方法达到并发操作呢. 方法是有的, 那就是把所有操作设置为非阻塞的.

实现如下:

```C++
int main() {
	Ak_LogInit(NULL, TRUE, TRUE);
	Ak_pSocketBase pstSB = Ak_NewSocket();
	int iCSocketFd = Ak_CreateSocket(pstSB, AF_INET, SOCK_STREAM, 0);
	Ak_BindSocket(pstSB, "192.168.30.131", 5000);
	Ak_ListenSocket(pstSB, 100);
	int iSocket[1024];
	int n = 0;
	char buf[30];
	AK_CLS(buf, 30);
	/**< 监听Socket非阻塞 */ 	 
	Ak_SetBlocking(iCSocketFd, FALSE); 	
	while (1) { 		
		iSocket[n] = Ak_AcceptSocket(pstSB); 		
		if (iSocket[n]>0) {
			/**< 连接Socket非阻塞 */
			Ak_SetBlocking(iSocket[n++], FALSE);
		}
		int i;
		for (i = 0; i < n; i++) { 			
			while (1) { 				
				int iLen = Ak_RecvSocket(iSocket[i], buf, 30); //非阻塞的循环收数据 	
				if (iLen > 0) {
					AK_INFO("%d,%s", iLen, buf);
				} else {
					break;
				}
			}
		}
		sleep(1);
	}
}
```
例子比较简单, 没什么好详细说的, 这里主要注意两个设置非阻塞的的时候.一个是accept,一个是recv. 这样就可以达到并发的目的.缺点也明显比如说所有都处于非阻塞状态, 这样一直循环比较浪费CPU.大部分时候需要sleep下 切换下时间片,礼貌的让出CPU资源.
<!--more-->

####多进程并发模型:####

刚才已经说到如果是阻塞方式可以通过多进程来实现并发模型, 父进程用来accept客户的请求, 子进程用来处理连接套接字.
```C++
int main() {
	Ak_LogInit(NULL, TRUE, TRUE);
	Ak_pSocketBase pstSB = Ak_NewSocket();
	int iLisSocket = Ak_CreateSocket(pstSB, AF_INET, SOCK_STREAM, 0);
	Ak_BindSocket(pstSB, "192.168.30.131", 5000);
	Ak_ListenSocket(pstSB, 100);
	int iCSocketFd;
	while (1) {
		iCSocketFd = Ak_AcceptSocket(pstSB);
		int iPid = fork();
		if (iPid==0) {
			break;
		} else if (iPid > 0) { /**< 父进程关闭连接Socket,因为子进程拥有一份连接Socket */
			close(iCSocketFd);
		} else {
			AK_ERROR("fork error!");
		}
	}
	/**< 子进程 */
	close(iLisSocket); /**< 同理,子进程关闭监听Socket,因为父进程已经拥有一份监听Socket */
	char buf[100];
	while (1) {
		AK_CLS(buf, 100);
		int ret = Ak_RecvSocket(iCSocketFd, buf, 30);
		if (ret == 0) {
			close(iCSocketFd); /**< 断开连接, 主动关闭Socket */
			break;
		}
		printf("%s,%d\n", buf, ret);
		sleep(1);
	}
}
```
这个算比较经典的并发socket模型了, 这里有个缺点就是一个Client对应一个进程,不停的fork进程, 进程数是有限的, 当达到系统限制时,会出现异常的.其实也没什么比较好的解决方法, 一般是开始开启多个(先定义好小于系统限制内)socket进行accept,如果连接达到固定进程数则不允许再来用户请求.这个缺点比较明显只能接受少量固定用户的请求数,比较适合用户少,但是数据传输比较多的时候.

让我们来看下具体实现:
```C++
int main() {

	Ak_LogInit(NULL, TRUE, TRUE);
	Ak_pSocketBase pstSB = Ak_NewSocket();
	int iLisSocket = Ak_CreateSocket(pstSB, AF_INET, SOCK_STREAM, 0);
	Ak_BindSocket(pstSB, "192.168.30.131", 5000);
	Ak_ListenSocket(pstSB, 100);
	int iCSocketFd;
	int i;
	int iPid;
	for (i = 0; i < 2; i++) { /**< 开启10个进程 */
		iPid = fork();
		if (iPid == 0) {
			printf("ChildPid=%d\n", getpid());
			break; /**< 子进程跳出 */ 	
		} else if (iPid > 0){
			/**< 父进程 */
		} else {
			AK_ERROR("Fork error!");
		}
	}
	/**< 父进程 */ 	if (iPid > 0) {
		/**< 回收子进程 */
		wait(NULL);
	}
	/**< 子进程 */
	if (iPid == 0) {
		while (1) {
			iCSocketFd = Ak_AcceptSocket(pstSB);
			while (1) {
				char buf[100];
				AK_CLS(buf, 100);
				int ret = Ak_RecvSocket(iCSocketFd, buf, 30);
				if (ret == 0) {
					AK_INFO("Close SocketFd=%d", iCSocketFd);
					close(iCSocketFd); /**< 断开连接, 主动关闭Socket */
					break;
				}
				printf("%s,%d\n", buf, ret);
				sleep(1);
			}
		}
	}
}
```

####多线程并发模型 ####
多线程并发模型主要是来一个客户端开一个线程,线程内是阻塞的,单独处理一个请求,所以这里面可以用同步IO模型, 但是各个线程是互相单独的,一个线程阻塞不会引起另外的线程的同步.

实现如下:
```C++
void handleData(int _iSocketFd) {
	char zcbuf[100];
	while (1) {
		AK_CLS(zcbuf, 100);
		int ret = Ak_RecvSocket(_iSocketFd, zcbuf, 30);
		if (ret == 0) {
			close(_iSocketFd); /**< 断开连接, 主动关闭Socket */
			break;
		}
		printf("%s,%d\n", zcbuf, ret);
	}
}

void* handle(void* _arg) {
	pthread_detach(pthread_self());
	handleData((int)_arg);
	return (void*)NULL;
}

int main() {
	Ak_LogInit(NULL, TRUE, TRUE);
	Ak_pSocketBase pstSB = Ak_NewSocket();
	int iLisSocket = Ak_CreateSocket(pstSB, AF_INET, SOCK_STREAM, 0);
	Ak_BindSocket(pstSB, "192.168.30.131", 5000);
	Ak_ListenSocket(pstSB, 100);
	pthread_t tid;
	int iCSocketFd;
	while (1) {
		iCSocketFd = Ak_AcceptSocket(pstSB);
		pthread_create(&tid, NULL, &handle, (void*)iCSocketFd);
		sleep(1);
	}
}
```
####I/O复用(select)并发模型####
首先说下select函数,该函数允许进程告诉内核等待多个事件中的任何一个发生,并仅有在一个或多个事件发生或经历一段指定的时间后才唤醒它.比如可以调用select告诉内核在1,2,3,4,5这些fd准备好读写,如果某个fd发生变化,如”写就绪”,函数会立即返回,并且通知进程写入数据. 所以根据这个特点可以用来对Socket(Everythin is a file!)进行监控.

实现如下:
```C++
int main() {
	Ak_LogInit(NULL, TRUE, TRUE);
	Ak_pSocketBase pstSB = Ak_NewSocket();
	int iLisSocket = Ak_CreateSocket(pstSB, AF_INET, SOCK_STREAM, 0);
	Ak_BindSocket(pstSB, "192.168.30.131", 5000);
	Ak_ListenSocket(pstSB, 100);
	fd_set fdset;
	struct timeval timeout;
	int num = 0;
	int iSocketFd[1024];
	char zcBuf[30];
	while (1) {

		FD_ZERO(&fdset);
		FD_SET(iLisSocket, &fdset); /**< 监控监听Socket */
		int i;
		for (i = 0; i < num; i++) {
			FD_SET(iSocketFd[i], &fdset); /**< 监控连接Socket */
		}

		timeout.tv_sec = 0;
		timeout.tv_usec = 100000;

		/**< select检测 */
		int iRet = select(FD_SETSIZE+1, &fdset, NULL, NULL, NULL); /**< 最后一个参数为timeout,可以设置为&timeout! */
		if (0 == iRet) { /**< 超时,也是瓶颈所在,需要一直扫描fd,很占CPU*/
			AK_ERROR("Select timeout!");
			continue;
		} else if (-1 == iRet) {
			AK_ERROR("Select error!");
			break;
		}

		/**< 如何是监听Socket */ 		
		if (FD_ISSET(iLisSocket, &fdset)) {
			iSocketFd[num]  = Ak_AcceptSocket(pstSB);
			if (iSocketFd[num] > 0) {
				num++;
			}
		} else {
			int j;
			for (j = 0; j < num; j++) {
				if (FD_ISSET(iSocketFd[j], &fdset)) { /**< 如果是监控连接Socket */
					AK_CLS(zcBuf, 30);
					int ret = Ak_RecvSocket(iSocketFd[j], zcBuf, 30);
					if (ret == 0) {
						AK_INFO("Close SocketFd=%d", iSocketFd);
						num--;
						break;
					}
					printf("%s\n", zcBuf);
				}
			}
		}

	}
}
```
这里要注意的是select的第一个参数, 这里为select的最大描述符, 也就是要扫描的描述符, 这里我设置为FD_SETSIZE,可以酌情增加. select优点很明显,函数select以阻塞的方式运行,大大节省CPU时间,另外一个优点是, 如果设置了select的timeout, 在timeout时间内,没有连接情况下,select将会自动返回0, 不会阻塞下去, 另外如果秒数和微秒数都指定为0, 根本不会等待, 直接返回, 这就是所谓的轮询. 缺点也很明显, 首先是单个进程被检测的fd数目受到限制,其次因为每调用一次select会轮询一次所有文件描述符,效率会随着客户端的数目而线性下降,不过在一定的集合范围内效率还是很不错的. 另外内核需要将消息传递到用户空间,都需要内核拷贝操作.

####epoll并发模型####

讲完select并发模型, 下面来看下比较给力的epoll并发,  稍微举个比较通俗的例子说下select和epoll的区别.

select: 某个村有经常有小偷, 所以就打电话派来一个select警察来监控, 这个select警察是这样处理事件的, 他从村的第一户村民开始问”你家丢东西了吗?” 这样一直问到最后一户村民.  一看就知道这样效率肯定不行.
epoll: 同样的场景,如果派来的是epoll警察,他会对大家说如果有丢东西的,就到我这边来注册. 没事不要打扰我.
呵呵, 一看就知道epoll比较明智了.

来看下Epoll的具体实现:
```C++
int main(int argc, const char** argv)
{
	Ak_LogInit(NULL, TRUE, TRUE);
	struct epoll_event ev;
	struct epoll_event events[MAX_OPEN_SIZE];
	struct rlimit rt;
	rt.rlim_max = rt.rlim_cur = MAX_OPEN_SIZE;
	if (setrlimit(RLIMIT_NOFILE, &rt) == -1) {
		AK_ERROR("setrlimit error");
		return -1;
	}

	Ak_pSocketBase pstSB = Ak_NewSocket();
	int iLisSocket = Ak_CreateSocket(pstSB, AF_INET, SOCK_STREAM, 0);
	Ak_BindSocket(pstSB, "192.168.30.131", 5000);
	Ak_ListenSocket(pstSB, 100);

	/**< 生成文件描述符 */
	/**< MAX_OPEN_SIZE为监听的数目 */
	int iFd = epoll_create(MAX_OPEN_SIZE);

	ev.events = EPOLLIN | EPOLLET;
	ev.data.fd = iLisSocket;

	/**< 控制某个fd上的事件(EPOLL_CTL_ADD/EPOLL_CTL_DEL/EPOLL_CTL_MOD) */
	if (epoll_ctl(iFd, EPOLL_CTL_ADD, iLisSocket, &ev) < 0) {
		AK_ERROR("epoll ctl error!");
		return -1;
	}

	while (1) {

		/**< 等待I/O的发生 */
		/**<    iFd->epoll专用描述符
		  events->处理事件的数组
		  MAX_OPEN_SIZE->每次能处理的事件个数
		  0->非阻塞 -1->阻塞
		  返回值->同一时间事件个数, =0为超时, -1出错
		 */
		int iFds = epoll_wait(iFd, events, MAX_OPEN_SIZE, -1);
		if (-1 == iFds) {
			AK_ERROR("epoll wait error!");
			break;
		}
		AK_INFO("EVNETS COUNT = %d", iFds);

		int i;
		for (i = 0; i < iFds; i++) {
			if (events[i].data.fd == iLisSocket) {
				int iCSocketFd = Ak_AcceptSocket(pstSB);
				if (iCSocketFd < 0) {
					AK_ERROR("Accept error!");
					continue;
				}
				Ak_SetBlocking(iCSocketFd, FALSE);
				ev.events = EPOLLIN | EPOLLET; /**< 将新连接也加入监听队列 */
				ev.data.fd = iCSocketFd;

				if (epoll_ctl(iFd, EPOLL_CTL_ADD, iCSocketFd, &ev) < 0) {
					AK_ERROR("epoll ctl error!");
					return -1;
				}

			} else if (events[i].events & EPOLLIN) { /**< 表示对应的文件描述符可以读 */
				char buf[100];
				AK_CLS(buf, 100);
				int ret = Ak_RecvSocket(events[i].data.fd, buf, 30);
				if (ret == 0) {
					close(events[i].data.fd); /**< 断开连接, 主动关闭Socket */
					break;
				}
				printf("%s,%d\n", buf, ret);

			} else if (events[i].events & EPOLLOUT) { /**< 表示对应的文件描述符可以写 */

			}
		}
	}

	return 0;
}
```
OK,到这最原型的并发网络模型讲的差不多了, 剩下的就是在这些模型中进行综合, 比如在epoll中加入多线程,加入队列. 比较经典的就是Nginx的一个线程Accept,多个worker线程.有时间的可以去看它源码,实现的不错.

